[{"id":"eabca4b5b506789d245f8d75823a2f80","title":"JavaScript核心(10)-運算子、優先性與相依性","content":"運算子JavaScript 具有二元運算子及一元運算子，以及比較特別的(條件)三元運算子。\n一元運算子具備一個運算元，一個運算子\n運算子 運算元\n運算元 運算子　　　// 例如: x++ 或 ++x　或 typeof x 、 delete x\n\n二元運算子具備兩個運算元，一個在前，一個在後\n運算元1 運算子 運算元2  // 例如 1 + 1 或 a * b\n\n三元運算子具備一個條件式、兩個表達式。條件後會跟著一個問號，如果條件是 true，冒號前的表達式會被執行，否則執行冒號後的表達式\ncondition ? express1 : express2\n\n看看以下範例：\nvar bmi = 20;\nvar b = (bmi &lt; 20) ? '偏瘦' : '有點肉';\n\nconsole.log(b)  // 回傳肉肉的\n\n如果 bmi &lt; 20 是 true，就顯示偏瘦，否則就顯示有點肉，並且會回傳一個結果。\n\n\n\n\n\n\nTIP\n三元運算子可以在條件式裡面再包一個條件式，就像 if 裡面 再包一個 if ，如下範例：\n\nvar bmi = 14;\n\nvar b = (bmi &lt; 20)  // bmi 小於 20 就進入下一個三元運算子，下面就以此類推\n? (bmi &lt; 15) ? '超級瘦' : '普通瘦'  \n: '有點肉';   \n\nconsole.log(b);  // 執行結果: 超級瘦\n\n\n運算子優先性及相依性Precedence 優先性運算子優先序( Operator precedence )決定了運算子彼此間被語法解析的方式，優先序高的運算子會成為優先序低的運算元，看看以下範例：\nvar a = 2 + 2 * 3;\nconsole.log(a) // 執行結果: 8\n\n結果為甚麼是 8 而不是 12 呢 ? 請看下面的優先性表格，數字越高優先性越高：\n\n\n\n優先性\n相依性\n運算子\n\n\n\n15\n從右至左\n…**…\n\n\n14\n從左至右\n…*…\n\n\n14\n從左至右\n…/…\n\n\n14\n從左至右\n…%…\n\n\n13\n從右至左\n…+…\n\n\n13\n從右至左\n…-…\n\n\n* 的優先性是 14，而 + 是 13，優先性高的會先運算，運算出來的數值變成優先性低的運算元，也就是 2 ＊ 3 的數值會變成 + 的運算元，之後再賦值到變數 a。\nAssociativity 相依性優先序相同時，就會使用相依性來決定運算方向，參考以下表格：\n\n\n\n優先性\n相依性\n運算子\n\n\n\n11\n從左至右\n…&lt;…\n\n\n11\n從左至右\n…&lt;=…\n\n\n11\n從左至右\n…&gt;…\n\n\n11\n從左至右\n…&gt;=…\n\n\n16\n從右至左\n++…\n\n\n17\n無\n…++\n\n\n14\n從左至右\n…*…\n\n\n// 範例 1.\nconsole.log(1 > 2 > 3) // false\n\n// 範例 2.\nvar a = 1 \nconsole.log(a++ * a) // 2\n\n// 範例3.\nvar b = 1\nconsole.log(++b * b) // 4\n","slug":"JavaScript核心(10)-運算子、優先性與相依性","date":"2021-10-08T09:38:07.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"},{"id":"81fd55e235ac1d2da0d07a77f95b851b","title":"JavaScript核心(9)-型別","content":"動態型別JavaScript是弱型別，也能說是動態程式語言。也就是說不必像 C 語言一樣特別宣告變數的型別。程式在執行時會自動轉換並確立型別。\nvar a = 42;      // a 目前是數字\nvar a = 'hello'; // a 目前是字串\nvar a = true;    // a 目前是布林值\n\nJavaScript 在轉換型別當中有非常大的陷阱，我們來看看以下程式碼 :\nvar num = 1;\nconsole.log(num, typeof num);  // 執行結果: 1 \"number\"\nnum = num + '';\nconsole.log(num, typeof num);  // 執行結果 : 1 \"string\"\n\n可以看到 num 印出的第一個結果是 1，然後型別是 number，而第二個印出的結果變成字串的原因是 num 加入了一個空字串，動態轉換了型別，所以 num 會變成字串型別。\n原始型別原始型別總共分為七種型別：\n\nBoolean (布林)\nNull (空值)\nUndefined (未定義)\nNumber (數值)\nString (字串)\nBigInt (整數數值)\nSymbol (整數數值)\n\n這些型別有各自的方法，比如說字串轉大小寫、取得字串長度，或者是數字取絕對值等等，而可以使用這些方法的原因是原始型別具有包裹物件：\n\n\n\n型別˙\n包裹物件\n\n\n\nBoolean\nnew Boolean()\n\n\nNull\n-\n\n\nUndefined\n-\n\n\nNumber\nnew Number()\n\n\nString\nnew String()\n\n\nBigInt\nBigInt()\n\n\nSymbol\nSymbol()\n\n\n\n\n\n\n\n\n\nWARNING\n需要注意的是只有 Null 以及 Undefined 沒有包裹物件。\n\n\n我們可以用 typeof 一一確認變數型別，參考以下範例：\nvar a, b, c, d;\na = 1;\na = '文字';\nb = true;\nc = &#123;&#125;;\nd = null;\nconsole.log(typeof a, typeof b, typeof c, typeof d, typeof e)\n// String, Boolean, Object, Object, undefined\n\n而為甚麼 null 印出來的型別會是 Object 呢 ? 這是 JavaScript 長久以來的錯誤，但它也沒辦法修正錯誤，因為有許多網站透過這種錯誤來完成網站應用，如果修正可能會導致網站出錯。\n\n\n\n\n\n\nTIP\n可以用 typeof 來檢查一個未宣告的變數，這時會印出 undefined， 這是 typeof  針對 not defined 的保護措施。\n\n\n接著用以下範例來說明，為甚麼一個字串變數能使用各種操作字串的方法：\nvar a = 'tom';\n\nconsole.log(a.length, a.toUpperCase(), a.trim());\n\nvar e = new String(a);\nconsole.log(a, e);\n// tom, String &#123;\"tom\"&#125;\n\nconsole.log(typeof e);\n// object\n透過開發者工具並且把 String 點開會包含 3 個字串以及 _proto_ ，如下圖 ：\n\n_proto_ 就是這個包裹物件的原型，方法都藏在裡面。使用原始型別的時候，JavaScript 會自動把包裹物件套用進來，但在宣告原始型別時盡量不要以 var e = new String(a) 這種方式來宣告，這種方法稱為建構式，透過 typeof e 可以看到它目前的型別是”物件”，跟原本操作方式會不同。\n","slug":"JavaScript核心(9)-型別","date":"2021-10-08T08:55:55.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"},{"id":"f2aac153324ba3bfd30225ae950ba730","title":"JavaScript核心(7)-陳述式與表達式","content":"Statement 陳述式JavaScript 的語句類型，用於命令執行指定的一系列操作，最大特徵就是不會回傳結果，例如: if-else、for。\nExpression 表達式(運算式)又可稱為表達式或運算式，經常透過一些符號結合上下語句並運算及回傳結果。\n可以在開方者工具下輸入以下程式碼：\n// Statement\nvar tom = '湯姆'  // 不會回傳任何結果\n\n// Expression\n100 + 100  // 回傳200\ntom = '哈囉湯姆' // 會回傳哈囉湯姆\n\n// 函式陳述式、具名函式\nfunction callName() &#123; &#125;\n\n// 函式表達式、匿名函式\nvar callName = function() &#123; &#125;\n\n\n詳細介紹可參考MDN：陳述式與宣告 - JavaScript | MDN\n","slug":"JavaScript核心(7)-陳述式與表達式","date":"2021-10-08T08:52:25.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"},{"id":"13acb8ef4e4194e0a3601d51af0c808e","title":"JavaScript核心(8)-ASI 自動插入分號","content":"ASI(Automatic Semicolon Insertion)是 JavaScript 的規則，當程式碼沒有加上分號時，會受到 ASI 自動插入分號規則的影響。來看看以下程式碼：\nfunction callName() &#123;\n\treturn\n\t'叫我小明';\n&#125;\nconsole.log(callName); // undefined\n\n執行出來的結果會是 undefined，原因是 return 空行之後，會受 ASI 影響，實際執行結果會變成這樣:\nfunction callName() &#123;\n\treturn; '叫我小明';\n&#125;\nconsole.log(callName); // undefined\n\n我們再來看看另一段程式碼：\nif(1 > 10) a = 1 else a = 2 console.log(a)\n\n// 執行結果: Uncaught SyntaxError: Unexpected token 'else'\n\n這裡因為 ASI 沒正確啟用，所以不會有 ASI 自動插入分號，理所當然地會跳錯，除錯的方法就是在 a = 1、a = 2 後面加入分號，就能成功運行。\n以下是不會發生 ASI 規則的情況： \n1. 新的一行是以 '('、 '['、 '/' 開始 (容易出錯的地方)\n\nvar b = a\n(a + b).toString()\n(function() &#123; &#125;)()\n(function() &#123; &#125;)()\nvar a = 1\nvar b = a\n/test/.test(b)\n\n2. 新的一行以 `+`、`-`、`*`、`%` 作開始 (會影響執行結果)\n\nvar a = 2\nvar b = a\n+a\n\n3. 新的一行以 `,`、`.` 作開始 (需注意執行結果)\n\nvar a = 2\nvar b = a\n.toString()\nconsole.log(typeof b)\nvar a = 1\n,b = 2 // 這裡 b 一樣會 var 被宣告\n\n遇到以上問題，在前面加入分號也是解決方法， 如:\n\n;(function() &#123; &#125;)()\n;(function() &#123; &#125;)()\n\n\n\n\n\n\n\nTIP\n需要知道 ASI 的規則是因為 JavaScript 有個叫 ESLint 的風格管理器，而 ESLint 其中一種風格【Standard】就是提倡不加入分號。\n\n","slug":"JavaScript核心(8)-ASI自動插入分號","date":"2021-10-08T08:51:02.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"},{"id":"bdb76982bd96f93dcf660de6d1a44759","title":"JavaScript核心(6)-執行緒與同步、非同步","content":"單執行緒與多執行緒(Single-Thread and Mulitple-Thread)JavaScript 是一個單執行緒的程式語言，單執行緒是一個作業系統的運作概念。以下圖為例，小明在早上有三個任務，而這些任務不能同時做，小明必須先吃完早餐，然後打給漂亮阿姨後，最後在去洗盤子；而多執行緒則反之，小明可以同時執行這些任務。\n\n同步與非同步(sync and async)在同步模式下，每個任務要照順序執行，後面任務必須等待前面任務執行完畢，非同步則反之，後面任務的不需要等待前面的任務結束，而是各自執行各自的任務。\n\n我們用以下程式碼來講講非同步的處理 : \nfunction eatBreakfast() &#123;\n\tconsole.log('吃早餐');\n&#125;\n\nfunction washPlate()&#123;\n\tconsole.log('洗盤子');\n&#125;\n\nfunction callSomeone(someone) &#123;\n\tconsole.log('打給' + someone);\n\tsetTimeout(() => &#123;\n\t\tconsole.log(someone + '回電')\n\t&#125;, 1000);\n&#125;\n\nfunction doWork() &#123;\n\tvar aunt = '阿姨';\n\teatBreakfast();\n\tcallSomeone(aunt);\n\twashPlate();\n&#125;\n\ndoWork();\n\n// 吃早餐\n// 打給阿姨\n// 洗盤子\n// 阿姨回電\n\n一開始會先執行 doWork() ，再來執行裡面的 eatBreakfast()，輪到執行 callSomeone() 的時候，裡面的 setTimeout() 這個非同步任務不會先執行，而是會移動到 “事件佇列(Event queue)” 裡，並繼續執行 washPlate()，等到 doWork() 同步執行完成後，setTimeout() 才會執行 ，要注意的是setTimeout() 裡的秒數怎麼調整都不會優先執行。\n\n可以參考以下有關事件佇列的說明 : 並行模型和事件循環 - JavaScript | MDN\n","slug":"JavaScript核心(6)-執行緒與同步、非同步","date":"2021-10-08T08:41:07.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"},{"id":"41a55d510962c7a81bbb07b635138fa7","title":"JavaScript核心(5)-記憶體存放與釋放","content":"回收機制(Garbage collection)function sayHi(name) &#123;\n\tvar greeting = 'hi';\n\treturn greeting + '' + name;\n&#125;\n\nfunction doSomething() &#123;\n\tvar mon = '老媽';\n\t\n\tconsole.log(1, sayHi(mon));\n&#125;\n\ndoSomething();\n黑色方塊代表記憶體，當 sayHi() 執行完後，它的執行堆疊會離開，而記憶體也會同時釋放掉，再來是 doSomething()，就跟 sayHi() 一樣，以此類推 ，最後僅留下 “全域執行環境” 所占存的記憶體。\n可以參考一下回收機制規則：記憶體管理 - JavaScript | MDN\n\n用另一段程式碼來看看其他情況 : \n// 隨機產生字串\nfunction randomString(len) &#123;\n\tvar result = '';\n\tvar char = 'abcederglfgithd';\n\tvar charLength = char.length;\n\tfor(var i = 0; i &lt; len; i++) &#123;\n\t\tresult += char.charAt(Math.floor(Math.random() * charLength));\n\t&#125;\n\treturn result\n&#125;\n\nfunction getData()&#123;\n\tvar demoData = [];\n\tfor(var i = 0; i &lt; 1000; i++) &#123;\n\t\tdemoData.push(randomString(5000));\n\t&#125;\n\tconsole.log(demoData); // Chrome console裡的行為中的行為也需要記憶體\n&#125;\n\ngetData();\n\n打開開發者工具的 Memory 看看執行程式的執行結果以及占掉多少記憶體\n\n照理說函式執行完畢，記憶體就會跟著執行堆疊離開而釋放，但檢查後記憶體會發現記憶體沒釋放，這是為甚麼呢?\n這裡要先把 console 裡的東西移除掉，再來去檢查 memory ，會發現記憶體被釋放了，這是因為 console 裡的行為也需要記憶體。\n\n","slug":"JavaScript核心(5)-記憶體存放與釋放","date":"2021-10-08T08:28:15.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"},{"id":"fb2e8d543ead028edd5fc18c6f464347","title":"JavaScript 核心(4)-提升(hoisting)","content":"Hoisting(提升)是一種釐清 JaveScript 在執行階段如何運行的思路（尤其是在創建和執行階段）。然而，提升可能會讓人誤解：例如，提升看起來是單純將變數和函式宣告，移動到程式區塊的頂端，然而並非如此。變數和函數的宣告會在編譯階段就被放入記憶體，但實際位置和程式碼中完全一樣。\n執行環境會分為兩種階段 :\n\n創造階段\n執行階段\n\n以 var a = 1 來說：\n\n在創造階段中會先把變數 a 放到記憶體，但還不會賦予值，這時檢查會是 undefined。\n在執行階段賦予 1 這個值。\n\n\n\n\n\n\n\nTIP\n要注意的是 “函式陳述式” 在創造階段就會優先載入。\n\n\n來看看範例: \nwhosName()\n\nfunction whosName() &#123;\n  if (myName) &#123;\n    myName = '杰倫'\n  &#125;\n&#125;\nvar myName = '小明'\n\nconsole.log(myName)\n\n上述程式碼經過 hoisting 後：\n//創造階段\nfunction whosName() &#123;\n\tif (myName) &#123;\n\t\tmyName = '杰倫';\n\t&#125;\n&#125;\n\nvar myName;\n\n//執行階段\n\nwhosName();\n\nmyName = '小明';\n\nconsole.log(myName);\n\n\n1.在創造階段時 “函式優先” ，所以 whosName() 會先被往上提，此時 myName 的值是 undefined，所以 if(myName) 的條件不成立。\n2.whosName() 的作用域找不到 myName，結果為 undefined，所以不會執行 myName = &#39;杰倫&#39;。\n3.myName = &#39;小明&#39;，已被賦予 myName，所以印出來的結果為 小明 。\n","slug":"JavaScript核心(4)-提升","date":"2021-10-08T07:49:42.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"},{"id":"f1ee2e5d0a69b1f49650eb6d8658482d","title":"JavaScript 核心(3)-範圍鍊(Scope chain)","content":"外部環境會依照函數本身的環境去尋找要取用的變數(程式碼寫在哪裡)，如果找不到會再往範圍鏈上去找，直到全域執行環境，\n參考以下程式碼 : \nvar value = 1;\n\nfunction fn1() &#123;\n\tconsole.log(value);\n&#125;\n\nfunction fn2() &#123;\n\tvar value = 2;\n\tfn1();\n&#125;\n\nfn2(); // 1\n\n這裡 fn1() 和 fn2() 的範圍鍊指向全域環境，跟執行環境沒任何關係；在執行 fn2() 時，裡面的 fn1() 會查找到全域的 value，而不是 fn2() 裡的 value。\n另一個範例：\nvar person = '老媽';\n\nfunction sayHi() &#123;\n  console.log('hi' +　person);\n&#125;\n\nfunction doWork() &#123;\n  var preson = '老爸';\n  function mettAuntie() &#123;\n    var person = '阿姨';\n    console.log('哈囉~' + person);\n  &#125;\n\n  sayHi();\n  mettAuntie();\n&#125;\n\ndoWork(); // hi老媽  哈囉~阿姨 \n執行 doWork() 後：\n\n執行 sayHi() ，函式裡沒有 person 變數，所以向外查找到全域的 person，印出 hi老媽。\n執行 mettAuntie()，函式裡有 person，所以直接取用它，印出 哈囉~阿姨。 \n\n","slug":"JavaScript核心(3)-範圍鍊","date":"2021-10-08T07:37:55.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"},{"id":"30b605c41c930f0491bf4de6a3f75a4d","title":"JavaScript 核心(2)-執行環境與執行堆疊","content":"執行環境(Execution environment)\n如果沒執行函式，函式裡的變數不會產生，並且需要執行函式才會產生執行屬於它的執行環境。\n\n全域環境會在瀏覽器開啟或是 node.js 後端啟動時建立，並且是瀏覽器就會產生 window 全域變數，如果是 node.js 就會產生 global 全域變數。\n執行堆疊(Execution stack)參考以下範例 : \nfunction sayHi(name) &#123;\n\tvar greeting = 'hi';\n\treturn greeting + '' + name;\n&#125;\n\nfunction doSomething() &#123;\n\tvar mon = '老媽';\n\t\n\tconsole.log(1, sayHi(mon));\n&#125;\n\ndoSomething();\n\n網頁一開啟時，會產生一個全域執行環境， 當 doSomething() 被執行時 ，會產生 doSomething() 的執行環境並向上堆疊 ，再來呼叫 sayHi() ，產生 SayHi() 執行環境後繼續向上堆疊。執行環境就是這樣一層一層向上堆疊，跟函式的宣告沒有關連性，而是與呼叫的位置相關。\n\n執行堆疊在離開時也是一樣，sayHi() 會先離開，再來是 doSomething() ，最後剩下全域的執行環境。\n","slug":"JavaScript核心(2)-執行環境與執行堆疊","date":"2021-10-08T07:27:36.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"},{"id":"6258e762300792bc057a2b358e905b3b","title":"JavaScript 核心(1)-語法作用域","content":"JavaScript是語法作用域(靜態作用域)\n語法作用域 :  又稱靜態作用域，在語法解析時，就已經確定作用域，且不會再改變。\n動態作用域 :  變數的作用域再函式調用的時候才會決定。\n看看以下範例 :\nvar value = 1;\nfunction fn1 () &#123;\n\tconsole.log(value);  // 向外查找會找到 value = 1\n&#125;\nfunction fn2 () &#123;\n\tvar value = 2;  // 這段變數只會在 fn2() 裡作用\n\tfn1();\n&#125;\nfn2();\n\n因為 JavaScript 是語法作用域(靜態作用域)，作用域在語法解析時就已經確定了；value = 2 只能在 fn2() 裡作用，而 fn2() 裡的 fn1() 被執行時會向外查找全域的 value = 1 。\n如果是動態作用域的話會取到 value = 2 的值 ，因為變數的 作用域在函式調用的時候決定，因此當而 fn2() 裡的 fn1() 被執行時，會取到 value = 2 。\n","slug":"JavaScript核心(1)-語法作用域","date":"2021-10-01T02:35:08.000Z","categories_index":"","tags_index":"JavaScript","author_index":"tommm2"}]