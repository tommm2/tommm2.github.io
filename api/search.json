[{"id":"2296c2316579b79c6d630a59768df5d0","title":"JavaScript核心觀念 (15)- 物件與純值","content":"在上篇提及了物件可用點記號或中括號來新增值一樣可新增屬性，那我們來看看以下範例：\nvar newString &#x3D; &#39;Hello World&#39;\nnewString.name &#x3D; &#39;new Hello&#39;\nconsole.log(newString.name)　&#x2F;&#x2F; undefined\n\n可以看到 newString.name 出來的結果會是 undefined，原因是 newString 這個變數是一個 純值，無法像物件一樣可以新增屬性。\n嘗試用 new String() 包裹物件來看看結果：\nvar newString2 &#x3D; new String(&#39;Hello World&#39;)\nnewString2.name &#x3D; &#39;new Hello&#39;\n\nconsole.log(newString2) &#x2F;&#x2F; String &#123;&#39;Hello World&#39;, name: &#39;new Hello&#39;&#125;\n\n可以看到 name 被賦予進去了，代表 newString2 是一個物件。\n來試試看用陣列能不能增加屬性：\nvar newArr &#x3D; [1, 2, 3]\nnewArr.name &#x3D; &#39;Hello arr&#39;\nconsole.log(newArr) \n\ntypeof newArr  &#x2F;&#x2F; 回傳 Object\n\n可以看到陣列也可添加屬性，代表陣列也是一個 物件型別，如果不信可以使用 typeof 做查詢。\n接下來用函式來做個範例：\nfunction HelloWorld() &#123;\n\tconsole.log(&#39;Hello World&#39;)\n&#125;\n\nconsole.log(typeof HelloWorld) &#x2F;&#x2F; 回傳 function\n\nconsole.dir(HelloWorld)\n\n你可能會很納悶明明 JavaScript 只有純值還有物件 ，為甚麼會跑出 function 呢? 需要注意的是 function 是一個物件型別下的子型別，可以透過 console.dir() 看到 HelloWorld 裡包了許多屬性。\n\n嘗試將一個屬性加入 HelloWorld 會發現成功被加入了。\n\n\n\n\n\n\n\nWARNING\n要注意 HelloWorld 裡的 name 屬性無法被修改，因為 name 是函式本身的名字。\n\nfunction HelloWorld() &#123;\n\tconsole.log(&#39;Hello World&#39;)\n&#125;\n\nHelloWorld.world &#x3D; &#39;Hello World&#39;\n\n&#x2F;&#x2F; 如果是賦予 name 屬性新值，name 也不會改變\nHelloWorld.name &#x3D; &#39;one_two&#39;\nconsole.dir(HelloWorld)\n\n\n","slug":"JavaScript核心觀念(15)-物件與純值","date":"2021-10-11T07:37:24.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"3575803f69cb1026cdab940a86a96665","title":"JavaScript核心(14)-物件取值、新增、刪除","content":"物件新增及取值物件取值的方式有兩種，有 點記法(Dot notation) 以及 中括號記法：\n點記法點記法很直觀的，就是運用 . 在物件裡新增屬性：\nvar family = &#123;&#125;\n\nfamily.dog = 'doggy'\n\nconsole.log(family.dog) // doggy\n\n中括號記法透過相關的名稱來選擇對象。中括號記法不僅能透過 字串 的方式來取值，也能透過 變數 的方式來取值，並且可以用 數字 或者是 特殊符號 作為屬性名稱：\nvar family = &#123;\n\tname: 'tom',\n\tdeposite: 1000,\n\tmembers: &#123;\n\t\tmom: 'adrew',\n\t\tsister: 'lucy'\n\t&#125;,\n\t1: '我是1',\n\t'*$$*': '我是錢字號還有星星',\n\tcallMyName: function() &#123;\n\t\tconsole.log(\"I'm Tom\")\n\t&#125;\n&#125;\n\nvar a = 'name';\nconsole.log(family[a]) // tom\nconsole.log(family[1]) // '我是1'\n\n// 雖說是特殊符號，但一樣是使用字串方式取值、但點記法做不到這件事\nconsole.log(family['*$$*']) // 我是錢字號還有星星\n\n// 函式呼叫方式\nconsole.log(family.callMyName()) // I'm Tom\nconsole.log(family['callMyName']()) // I'm Tom\n\ndelete 操作符delete 能刪除物件的屬性或方法，但不會刪除物件原型的屬性或方法。\n試著用 delete 把一些屬性刪除:\nvar family = &#123;\n\tname: 'tom',\n\tdeposite: 1000,\n\tmembers: &#123;\n\t\tmom: 'adrew',\n\t\tsister: 'lucy'\n\t&#125;,\n\t1: '我是1',\n\t'*$$*': '我是錢字號還有星星',\n\tcallMyName: function() &#123;\n\t\tconsole.log(\"I'm Tom\")\n\t&#125;\n&#125;\n\ndelete family['*$$*'] // 會回傳 true\ndelete family.callMyName() // 會回傳 true、 I'm Tom\n\n// console之後會發現值不見了\nconsole.log(family)\n\n額外補充：變數及物件屬性的差異輸入以下程式碼，會發現 a 和 b 的被賦予到 window 這個根物件上面了，但這兩者實際上是有所不同的：\nvar a = 2\nb = 3\nconsole.log(winodw)\n\n特別說明一下，如果是一個變數，是無法使用 delete 刪除的。來試試看把 a 和 b 都刪除，會發現 a 還留著、但是 b 會消失，原因是 a 是以變數方式作新增，所以無法被刪除、而 b = 3 實際上是執行這段 window.b = 3 ，如下範例：\nvar a = 2\nb = 3  // 這裡實際上會變成這樣 :　window.b = 3\n\ndelete a // 會回傳 false ， 因 a 是變數，無法被刪除\ndelete b // 回傳 true\n\nconsole.log(winodw)\n","slug":"JavaScript核心(14)-物件取值、新增、刪除","date":"2021-10-11T07:21:03.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"c5d47a728f0d1387eb297fe3f1645b3f","title":"JavaScript核心(13)-邏輯運算子及函式預設值","content":"邏輯運算子通常被用於 Boolean; 使用於 Boolean 時，它們會回傳 Boolean type(true or false)。 但是 &amp;&amp; 和 || 運算子實際上是回傳指定的運算元之一，所以如果用在不是布林值時，它會回傳一個不是 Boolean Type 的值。 \n邏輯 AND (&amp;&amp;) :Usage：運算式1 &amp;&amp; 運算式2\n如果 運算式1 是 false，回傳 運算式1；否則，回傳 運算式2 。 &amp;&amp; 只有在 兩個運算元都是 true 時才會回傳 true，否則回傳 false。\n邏輯 OR ( || )：Usage：運算式1 || 運算式2\n如果 運算式1 是 true ，回傳 運算式1；否則，回傳 運算式2。 因此，|| 在兩個運算元有任一個是 true 時就會回傳 true，否則回傳 false。\n邏輯 NOT ( ! )：Usage：!運算式\n描述：如果一個運算元能被轉換成 true 時，回傳 false，否則回傳 true。\n參考以下範例：\nvar a1 = null &amp;&amp; true     // f &amp;&amp; t 回傳 null\nvar a2 = undefined &amp;&amp; 'a' // f &amp;&amp; t 回傳 undefined\nvar a3 = [] &amp;&amp; 'z'        // t &amp;&amp; t 回傳 'z'\n\nvar b1 = null || true     // f || t 回傳 true\nvar b2 = [] || 'aa'       // t || t 回傳 []\nvar b3 = NaN || undefined // f || f 回傳 undefined\n\nvar c1 = !null             // !f 回傳 true\nvar c2 = !&#123;&#125;               // !t 回傳 false\nvar c3 = !0                // !f 回傳 true\n\n除此之外還可以使用邏輯運算子來預設數值，避免出現 undefined 或 NaN 的錯誤，參考以下範例：\nvar originCash = 500;\nfunction updateEasyCard(cash) &#123;\n  cash = cash || 100  // cash 會是 undefined ，所以回傳 100 \n  var money = cash + originCash;\n  console.log('我有 ' + money + ' 元');\n&#125;\nupdateEasyCard();\n\n特別要注意的是如果再 updateEasyCard() 帶入 0 的話，在邏輯運算裡會被判定成假值，所以可以透過三元運算子來處理：\nvar originCash = 500;\nfunction updateEasyCard(cash) &#123;\n  cash = parseInt(cash);\n  console.log(cash);\n  // 當 cash 是數值或為 0 時，使用 cash 的數值\n  // 如果 cash 是 NaN 時，則直接套用 500\n  cash = (cash || cash === 0)? cash: 500;\n  var money = cash + originCash;\n  console.log('我有 ' + money + ' 元');\n&#125;\nupdateEasyCard(0);\n","slug":"JavaScript核心(13)-邏輯運算子及函式預設值","date":"2021-10-11T04:54:04.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"d65118ec8977c8f3d7fc37b754ab5f87","title":"JavaScript核心(12)- Truth、Falsy","content":"在JavaScript中，Truthy (真值) 指的是布林值中，轉換後結果為真的值。所有值都是真值，除非它們被定義為假值，如：false、0、null、undefined、NaN 、&quot;&quot;、 &#39;&#39;  。\n以下範例將被轉換成true，if裡的程式碼段會被執行：\nif (true)\nif (&#123;&#125;)\nif ([])\nif (42)\nif (\"foo\")\nif (new Date())\nif (-42)\nif (3.14)\nif (-3.14)\nif (Infinity)\nif (-Infinity)\n\n以下範例將被轉換成false，並且if裡的程式碼段不會被執行：\nif (false)\nif (null)\nif (undefined)\nif (0)\nif (0n)\nif (NaN)\nif ('')\nif (\"\")\nif (``)\nif (document.all)\n","slug":"JavaScript核心(12)-Truth、Falsy","date":"2021-10-11T04:52:40.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"de988f7d07d61276e6603d4f3929c261","title":"JavaScript核心(11)-寬鬆相等、嚴格相等以及隱含轉型","content":"寬鬆相等 ( == )寬鬆相等會先將比較值 “轉換成同型別” 後比較。轉換後（可能一個或兩個都被轉換），接著進行的幾乎和嚴格比較（===）一樣。 一般相等會對稱：A == B 等同 B == A ，無論 A 和 B 是什麼。（除了型別轉換的順序）\n嚴格相等 ( === )嚴格相等比較兩個值，而被比較的兩個值都 “不會轉換” 成其他型別。如果值是不同型別，就會被視為不相等。如果兩值型別相同但不是數字，若值相同，則為相等。此外，如果兩個值皆為數字，只要他們是 NaN 以外的同一值，或者 +0 和 -0，則為相等。\n// 寬鬆相等 : 在數字與布林或字串比對時，會將字串與布林值轉成數字\nconsole.log(1 == '1')  // true\nconsole.log(1 == true) // true  備註：true轉成數字會是1、false會是0\n\n// 嚴格相等 : 會比較型別及數值\nconsole.log(1 === '1')  // false\nconsoel.log(1 === true) // false\n// 特別案例\nconsole.log(NaN === NaN)  // false\nconsole.log(-0 === +0)  // true\n\n// 物件與非物件比對，會使用包裹物件做轉換\nconsole.log([10]) // 10\nconsole.log(10 == [10]) // true  備註: Number( [10] )回傳結果為 10\nconsole.log('A' == ['A']) // true 備註: String( ['A'] )回傳結果為 'A'\nconsole.log(String(&#123; A: 'A'&#125;)) // [object Object]\n\n// 物件與物件比對是透過參考位置來比對，所以以下結果會是 false\nconsole.log(&#123;&#125; == &#123;&#125;) // false  \nconsole.log([] == []) // false\n\nvar a = []\nb = a\nconsole.log(a == b) // true 備註:這裡是true的原因是b與a的參考位置一樣\n\n詳細介紹可以參閱MDN的相等比較：\n相等比較 - JavaScript | MDN\n","slug":"JavaScript核心(11)-寬鬆相等、嚴格相等以及隱含轉型","date":"2021-10-11T04:47:50.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"eabca4b5b506789d245f8d75823a2f80","title":"JavaScript核心(10)-運算子、優先性與相依性","content":"運算子JavaScript 具有二元運算子及一元運算子，以及比較特別的(條件)三元運算子。\n一元運算子具備一個運算元，一個運算子\n運算子 運算元\n運算元 運算子　　　// 例如: x++ 或 ++x　或 typeof x 、 delete x\n\n二元運算子具備兩個運算元，一個在前，一個在後\n運算元1 運算子 運算元2  // 例如 1 + 1 或 a * b\n\n三元運算子具備一個條件式、兩個表達式。條件後會跟著一個問號，如果條件是 true，冒號前的表達式會被執行，否則執行冒號後的表達式\ncondition ? express1 : express2\n\n看看以下範例：\nvar bmi = 20;\nvar b = (bmi &lt; 20) ? '偏瘦' : '有點肉';\n\nconsole.log(b)  // 回傳肉肉的\n\n如果 bmi &lt; 20 是 true，就顯示偏瘦，否則就顯示有點肉，並且會回傳一個結果。\n\n\n\n\n\n\nTIP\n三元運算子可以在條件式裡面再包一個條件式，就像 if 裡面 再包一個 if ，如下範例：\n\nvar bmi = 14;\n\nvar b = (bmi &lt; 20)  // bmi 小於 20 就進入下一個三元運算子，下面就以此類推\n? (bmi &lt; 15) ? '超級瘦' : '普通瘦'  \n: '有點肉';   \n\nconsole.log(b);  // 執行結果: 超級瘦\n\n\n運算子優先性及相依性Precedence 優先性運算子優先序( Operator precedence )決定了運算子彼此間被語法解析的方式，優先序高的運算子會成為優先序低的運算元，看看以下範例：\nvar a = 2 + 2 * 3;\nconsole.log(a) // 執行結果: 8\n\n結果為甚麼是 8 而不是 12 呢 ? 請看下面的優先性表格，數字越高優先性越高：\n\n\n\n優先性\n相依性\n運算子\n\n\n\n15\n從右至左\n…**…\n\n\n14\n從左至右\n…*…\n\n\n14\n從左至右\n…/…\n\n\n14\n從左至右\n…%…\n\n\n13\n從右至左\n…+…\n\n\n13\n從右至左\n…-…\n\n\n* 的優先性是 14，而 + 是 13，優先性高的會先運算，運算出來的數值變成優先性低的運算元，也就是 2 ＊ 3 的數值會變成 + 的運算元，之後再賦值到變數 a。\nAssociativity 相依性優先序相同時，就會使用相依性來決定運算方向，參考以下表格：\n\n\n\n優先性\n相依性\n運算子\n\n\n\n11\n從左至右\n…&lt;…\n\n\n11\n從左至右\n…&lt;=…\n\n\n11\n從左至右\n…&gt;…\n\n\n11\n從左至右\n…&gt;=…\n\n\n16\n從右至左\n++…\n\n\n17\n無\n…++\n\n\n14\n從左至右\n…*…\n\n\n// 範例 1.\nconsole.log(1 > 2 > 3) // false\n\n// 範例 2.\nvar a = 1 \nconsole.log(a++ * a) // 2\n\n// 範例3.\nvar b = 1\nconsole.log(++b * b) // 4\n","slug":"JavaScript核心(10)-運算子、優先性與相依性","date":"2021-10-08T09:38:07.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"81fd55e235ac1d2da0d07a77f95b851b","title":"JavaScript核心(9)-型別","content":"動態型別JavaScript是弱型別，也能說是動態程式語言。也就是說不必像 C 語言一樣特別宣告變數的型別。程式在執行時會自動轉換並確立型別。\nvar a = 42;      // a 目前是數字\nvar a = 'hello'; // a 目前是字串\nvar a = true;    // a 目前是布林值\n\nJavaScript 在轉換型別當中有非常大的陷阱，我們來看看以下程式碼 :\nvar num = 1;\nconsole.log(num, typeof num);  // 執行結果: 1 \"number\"\nnum = num + '';\nconsole.log(num, typeof num);  // 執行結果 : 1 \"string\"\n\n可以看到 num 印出的第一個結果是 1，然後型別是 number，而第二個印出的結果變成字串的原因是 num 加入了一個空字串，動態轉換了型別，所以 num 會變成字串型別。\n原始型別原始型別總共分為七種型別：\n\nBoolean (布林)\nNull (空值)\nUndefined (未定義)\nNumber (數值)\nString (字串)\nBigInt (整數數值)\nSymbol (整數數值)\n\n這些型別有各自的方法，比如說字串轉大小寫、取得字串長度，或者是數字取絕對值等等，而可以使用這些方法的原因是原始型別具有包裹物件：\n\n\n\n型別˙\n包裹物件\n\n\n\nBoolean\nnew Boolean()\n\n\nNull\n-\n\n\nUndefined\n-\n\n\nNumber\nnew Number()\n\n\nString\nnew String()\n\n\nBigInt\nBigInt()\n\n\nSymbol\nSymbol()\n\n\n\n\n\n\n\n\n\nWARNING\n需要注意的是只有 Null 以及 Undefined 沒有包裹物件。\n\n\n我們可以用 typeof 一一確認變數型別，參考以下範例：\nvar a, b, c, d;\na = 1;\na = '文字';\nb = true;\nc = &#123;&#125;;\nd = null;\nconsole.log(typeof a, typeof b, typeof c, typeof d, typeof e)\n// String, Boolean, Object, Object, undefined\n\n而為甚麼 null 印出來的型別會是 Object 呢 ? 這是 JavaScript 長久以來的錯誤，但它也沒辦法修正錯誤，因為有許多網站透過這種錯誤來完成網站應用，如果修正可能會導致網站出錯。\n\n\n\n\n\n\nTIP\n可以用 typeof 來檢查一個未宣告的變數，這時會印出 undefined， 這是 typeof  針對 not defined 的保護措施。\n\n\n接著用以下範例來說明，為甚麼一個字串變數能使用各種操作字串的方法：\nvar a = 'tom';\n\nconsole.log(a.length, a.toUpperCase(), a.trim());\n\nvar e = new String(a);\nconsole.log(a, e);\n// tom, String &#123;\"tom\"&#125;\n\nconsole.log(typeof e);\n// object\n透過開發者工具並且把 String 點開會包含 3 個字串以及 _proto_ ，如下圖 ：\n\n_proto_ 就是這個包裹物件的原型，方法都藏在裡面。使用原始型別的時候，JavaScript 會自動把包裹物件套用進來，但在宣告原始型別時盡量不要以 var e = new String(a) 這種方式來宣告，這種方法稱為建構式，透過 typeof e 可以看到它目前的型別是”物件”，跟原本操作方式會不同。\n","slug":"JavaScript核心(9)-型別","date":"2021-10-08T08:55:55.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"f2aac153324ba3bfd30225ae950ba730","title":"JavaScript核心(7)-陳述式與表達式","content":"Statement 陳述式JavaScript 的語句類型，用於命令執行指定的一系列操作，最大特徵就是不會回傳結果，例如: if-else、for。\nExpression 表達式(運算式)又可稱為表達式或運算式，經常透過一些符號結合上下語句並運算及回傳結果。\n可以在開方者工具下輸入以下程式碼：\n// Statement\nvar tom = '湯姆'  // 不會回傳任何結果\n\n// Expression\n100 + 100  // 回傳200\ntom = '哈囉湯姆' // 會回傳哈囉湯姆\n\n// 函式陳述式、具名函式\nfunction callName() &#123; &#125;\n\n// 函式表達式、匿名函式\nvar callName = function() &#123; &#125;\n\n\n詳細介紹可參考MDN：陳述式與宣告 - JavaScript | MDN\n","slug":"JavaScript核心(7)-陳述式與表達式","date":"2021-10-08T08:52:25.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"13acb8ef4e4194e0a3601d51af0c808e","title":"JavaScript核心(8)-ASI 自動插入分號","content":"ASI(Automatic Semicolon Insertion)是 JavaScript 的規則，當程式碼沒有加上分號時，會受到 ASI 自動插入分號規則的影響。來看看以下程式碼：\nfunction callName() &#123;\n\treturn\n\t'叫我小明';\n&#125;\nconsole.log(callName); // undefined\n\n執行出來的結果會是 undefined，原因是 return 空行之後，會受 ASI 影響，實際執行結果會變成這樣:\nfunction callName() &#123;\n\treturn; '叫我小明';\n&#125;\nconsole.log(callName); // undefined\n\n我們再來看看另一段程式碼：\nif(1 > 10) a = 1 else a = 2 console.log(a)\n\n// 執行結果: Uncaught SyntaxError: Unexpected token 'else'\n\n這裡因為 ASI 沒正確啟用，所以不會有 ASI 自動插入分號，理所當然地會跳錯，除錯的方法就是在 a = 1、a = 2 後面加入分號，就能成功運行。\n以下是不會發生 ASI 規則的情況： \n1. 新的一行是以 '('、 '['、 '/' 開始 (容易出錯的地方)\n\nvar b = a\n(a + b).toString()\n(function() &#123; &#125;)()\n(function() &#123; &#125;)()\nvar a = 1\nvar b = a\n/test/.test(b)\n\n2. 新的一行以 `+`、`-`、`*`、`%` 作開始 (會影響執行結果)\n\nvar a = 2\nvar b = a\n+a\n\n3. 新的一行以 `,`、`.` 作開始 (需注意執行結果)\n\nvar a = 2\nvar b = a\n.toString()\nconsole.log(typeof b)\nvar a = 1\n,b = 2 // 這裡 b 一樣會 var 被宣告\n\n遇到以上問題，在前面加入分號也是解決方法， 如:\n\n;(function() &#123; &#125;)()\n;(function() &#123; &#125;)()\n\n\n\n\n\n\n\nTIP\n需要知道 ASI 的規則是因為 JavaScript 有個叫 ESLint 的風格管理器，而 ESLint 其中一種風格【Standard】就是提倡不加入分號。\n\n","slug":"JavaScript核心(8)-ASI自動插入分號","date":"2021-10-08T08:51:02.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"bdb76982bd96f93dcf660de6d1a44759","title":"JavaScript核心(6)-執行緒與同步、非同步","content":"單執行緒與多執行緒(Single-Thread and Mulitple-Thread)JavaScript 是一個單執行緒的程式語言，單執行緒是一個作業系統的運作概念。以下圖為例，小明在早上有三個任務，而這些任務不能同時做，小明必須先吃完早餐，然後打給漂亮阿姨後，最後在去洗盤子；而多執行緒則反之，小明可以同時執行這些任務。\n\n同步與非同步(sync and async)在同步模式下，每個任務要照順序執行，後面任務必須等待前面任務執行完畢，非同步則反之，後面任務的不需要等待前面的任務結束，而是各自執行各自的任務。\n\n我們用以下程式碼來講講非同步的處理 : \nfunction eatBreakfast() &#123;\n\tconsole.log('吃早餐');\n&#125;\n\nfunction washPlate()&#123;\n\tconsole.log('洗盤子');\n&#125;\n\nfunction callSomeone(someone) &#123;\n\tconsole.log('打給' + someone);\n\tsetTimeout(() => &#123;\n\t\tconsole.log(someone + '回電')\n\t&#125;, 1000);\n&#125;\n\nfunction doWork() &#123;\n\tvar aunt = '阿姨';\n\teatBreakfast();\n\tcallSomeone(aunt);\n\twashPlate();\n&#125;\n\ndoWork();\n\n// 吃早餐\n// 打給阿姨\n// 洗盤子\n// 阿姨回電\n\n一開始會先執行 doWork() ，再來執行裡面的 eatBreakfast()，輪到執行 callSomeone() 的時候，裡面的 setTimeout() 這個非同步任務不會先執行，而是會移動到 “事件佇列(Event queue)” 裡，並繼續執行 washPlate()，等到 doWork() 同步執行完成後，setTimeout() 才會執行 ，要注意的是setTimeout() 裡的秒數怎麼調整都不會優先執行。\n\n可以參考以下有關事件佇列的說明 : 並行模型和事件循環 - JavaScript | MDN\n","slug":"JavaScript核心(6)-執行緒與同步、非同步","date":"2021-10-08T08:41:07.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"41a55d510962c7a81bbb07b635138fa7","title":"JavaScript核心(5)-記憶體存放與釋放","content":"回收機制(Garbage collection)function sayHi(name) &#123;\n\tvar greeting = 'hi';\n\treturn greeting + '' + name;\n&#125;\n\nfunction doSomething() &#123;\n\tvar mon = '老媽';\n\t\n\tconsole.log(1, sayHi(mon));\n&#125;\n\ndoSomething();\n黑色方塊代表記憶體，當 sayHi() 執行完後，它的執行堆疊會離開，而記憶體也會同時釋放掉，再來是 doSomething()，就跟 sayHi() 一樣，以此類推 ，最後僅留下 “全域執行環境” 所占存的記憶體。\n可以參考一下回收機制規則：記憶體管理 - JavaScript | MDN\n\n用另一段程式碼來看看其他情況 : \n// 隨機產生字串\nfunction randomString(len) &#123;\n\tvar result = '';\n\tvar char = 'abcederglfgithd';\n\tvar charLength = char.length;\n\tfor(var i = 0; i &lt; len; i++) &#123;\n\t\tresult += char.charAt(Math.floor(Math.random() * charLength));\n\t&#125;\n\treturn result\n&#125;\n\nfunction getData()&#123;\n\tvar demoData = [];\n\tfor(var i = 0; i &lt; 1000; i++) &#123;\n\t\tdemoData.push(randomString(5000));\n\t&#125;\n\tconsole.log(demoData); // Chrome console裡的行為中的行為也需要記憶體\n&#125;\n\ngetData();\n\n打開開發者工具的 Memory 看看執行程式的執行結果以及占掉多少記憶體\n\n照理說函式執行完畢，記憶體就會跟著執行堆疊離開而釋放，但檢查後記憶體會發現記憶體沒釋放，這是為甚麼呢?\n這裡要先把 console 裡的東西移除掉，再來去檢查 memory ，會發現記憶體被釋放了，這是因為 console 裡的行為也需要記憶體。\n\n","slug":"JavaScript核心(5)-記憶體存放與釋放","date":"2021-10-08T08:28:15.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"fb2e8d543ead028edd5fc18c6f464347","title":"JavaScript 核心(4)-提升(hoisting)","content":"Hoisting(提升)是一種釐清 JaveScript 在執行階段如何運行的思路（尤其是在創建和執行階段）。然而，提升可能會讓人誤解：例如，提升看起來是單純將變數和函式宣告，移動到程式區塊的頂端，然而並非如此。變數和函數的宣告會在編譯階段就被放入記憶體，但實際位置和程式碼中完全一樣。\n執行環境會分為兩種階段 :\n\n創造階段\n執行階段\n\n以 var a = 1 來說：\n\n在創造階段中會先把變數 a 放到記憶體，但還不會賦予值，這時檢查會是 undefined。\n在執行階段賦予 1 這個值。\n\n\n\n\n\n\n\nTIP\n要注意的是 “函式陳述式” 在創造階段就會優先載入。\n\n\n來看看範例: \nwhosName()\n\nfunction whosName() &#123;\n  if (myName) &#123;\n    myName = '杰倫'\n  &#125;\n&#125;\nvar myName = '小明'\n\nconsole.log(myName)\n\n上述程式碼經過 hoisting 後：\n//創造階段\nfunction whosName() &#123;\n\tif (myName) &#123;\n\t\tmyName = '杰倫';\n\t&#125;\n&#125;\n\nvar myName;\n\n//執行階段\n\nwhosName();\n\nmyName = '小明';\n\nconsole.log(myName);\n\n\n1.在創造階段時 “函式優先” ，所以 whosName() 會先被往上提，此時 myName 的值是 undefined，所以 if(myName) 的條件不成立。\n2.whosName() 的作用域找不到 myName，結果為 undefined，所以不會執行 myName = &#39;杰倫&#39;。\n3.myName = &#39;小明&#39;，已被賦予 myName，所以印出來的結果為 小明 。\n","slug":"JavaScript核心(4)-提升","date":"2021-10-08T07:49:42.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"f1ee2e5d0a69b1f49650eb6d8658482d","title":"JavaScript 核心(3)-範圍鍊(Scope chain)","content":"外部環境會依照函數本身的環境去尋找要取用的變數(程式碼寫在哪裡)，如果找不到會再往範圍鏈上去找，直到全域執行環境，\n參考以下程式碼 : \nvar value = 1;\n\nfunction fn1() &#123;\n\tconsole.log(value);\n&#125;\n\nfunction fn2() &#123;\n\tvar value = 2;\n\tfn1();\n&#125;\n\nfn2(); // 1\n\n這裡 fn1() 和 fn2() 的範圍鍊指向全域環境，跟執行環境沒任何關係；在執行 fn2() 時，裡面的 fn1() 會查找到全域的 value，而不是 fn2() 裡的 value。\n另一個範例：\nvar person = '老媽';\n\nfunction sayHi() &#123;\n  console.log('hi' +　person);\n&#125;\n\nfunction doWork() &#123;\n  var preson = '老爸';\n  function mettAuntie() &#123;\n    var person = '阿姨';\n    console.log('哈囉~' + person);\n  &#125;\n\n  sayHi();\n  mettAuntie();\n&#125;\n\ndoWork(); // hi老媽  哈囉~阿姨 \n執行 doWork() 後：\n\n執行 sayHi() ，函式裡沒有 person 變數，所以向外查找到全域的 person，印出 hi老媽。\n執行 mettAuntie()，函式裡有 person，所以直接取用它，印出 哈囉~阿姨。 \n\n","slug":"JavaScript核心(3)-範圍鍊","date":"2021-10-08T07:37:55.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"30b605c41c930f0491bf4de6a3f75a4d","title":"JavaScript 核心(2)-執行環境與執行堆疊","content":"執行環境(Execution environment)\n如果沒執行函式，函式裡的變數不會產生，並且需要執行函式才會產生執行屬於它的執行環境。\n\n全域環境會在瀏覽器開啟或是 node.js 後端啟動時建立，並且是瀏覽器就會產生 window 全域變數，如果是 node.js 就會產生 global 全域變數。\n執行堆疊(Execution stack)參考以下範例 : \nfunction sayHi(name) &#123;\n\tvar greeting = 'hi';\n\treturn greeting + '' + name;\n&#125;\n\nfunction doSomething() &#123;\n\tvar mon = '老媽';\n\t\n\tconsole.log(1, sayHi(mon));\n&#125;\n\ndoSomething();\n\n網頁一開啟時，會產生一個全域執行環境， 當 doSomething() 被執行時 ，會產生 doSomething() 的執行環境並向上堆疊 ，再來呼叫 sayHi() ，產生 SayHi() 執行環境後繼續向上堆疊。執行環境就是這樣一層一層向上堆疊，跟函式的宣告沒有關連性，而是與呼叫的位置相關。\n\n執行堆疊在離開時也是一樣，sayHi() 會先離開，再來是 doSomething() ，最後剩下全域的執行環境。\n","slug":"JavaScript核心(2)-執行環境與執行堆疊","date":"2021-10-08T07:27:36.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"},{"id":"6258e762300792bc057a2b358e905b3b","title":"JavaScript 核心(1)-語法作用域","content":"JavaScript是語法作用域(靜態作用域)\n語法作用域 :  又稱靜態作用域，在語法解析時，就已經確定作用域，且不會再改變。\n動態作用域 :  變數的作用域再函式調用的時候才會決定。\n看看以下範例 :\nvar value = 1;\nfunction fn1 () &#123;\n\tconsole.log(value);  // 向外查找會找到 value = 1\n&#125;\nfunction fn2 () &#123;\n\tvar value = 2;  // 這段變數只會在 fn2() 裡作用\n\tfn1();\n&#125;\nfn2();\n\n因為 JavaScript 是語法作用域(靜態作用域)，作用域在語法解析時就已經確定了；value = 2 只能在 fn2() 裡作用，而 fn2() 裡的 fn1() 被執行時會向外查找全域的 value = 1 。\n如果是動態作用域的話會取到 value = 2 的值 ，因為變數的 作用域在函式調用的時候決定，因此當而 fn2() 裡的 fn1() 被執行時，會取到 value = 2 。\n","slug":"JavaScript核心(1)-語法作用域","date":"2021-10-01T02:35:08.000Z","categories_index":"JavaScript核心","tags_index":"JavaScript","author_index":"tommm2"}]